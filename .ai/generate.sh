#!/usr/bin/env bash
# ============================================================================
# generate.sh - Multi-platform configuration generator
# ============================================================================
# Generates platform-specific configuration files from .ai/skills/*.yaml
#
# Supported platforms:
#   - AGENTS.md (standard)
#   - CLAUDE.md (Claude Code)
#   - .claude/agents/*.md (Claude Code subagents)
#   - .cursorrules (Cursor)
#   - .continuerc.json (Continue.dev)
#   - .aider.conf.yml (Aider)
#   - ollama/Modelfile.* (Ollama)
#   - .opencode/agents/*.md (OpenCode)
#   - .codex/agents/*.md (Codex CLI)
#
# Usage:
#   ./generate.sh [OPTIONS]
#
# Options:
#   --force     Force regeneration even if VERSION unchanged
#   --check     Check if regeneration is needed (exit 1 if yes)
#   --dry-run   Show what would be generated without writing
#   --verbose   Show detailed output
#   --help      Show this help message
#
# ============================================================================

set -euo pipefail

# ----------------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------------
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly SKILLS_DIR="${SCRIPT_DIR}/skills"
readonly VERSION_FILE="${SCRIPT_DIR}/VERSION"
readonly GENERATED_MARKER="Auto-generated by generate.sh"

# Platform output paths
readonly AGENTS_MD="${PROJECT_ROOT}/AGENTS.md"
readonly CLAUDE_MD="${PROJECT_ROOT}/CLAUDE.md"
readonly CLAUDE_AGENTS_DIR="${PROJECT_ROOT}/.claude/agents"
readonly CURSOR_RULES="${PROJECT_ROOT}/.cursorrules"
readonly CONTINUE_RC="${PROJECT_ROOT}/.continuerc.json"
readonly AIDER_CONF="${PROJECT_ROOT}/.aider.conf.yml"
readonly OLLAMA_DIR="${PROJECT_ROOT}/ollama"
readonly OPENCODE_AGENTS_DIR="${PROJECT_ROOT}/.opencode/agents"
readonly CODEX_AGENTS_DIR="${PROJECT_ROOT}/.codex/agents"

# Options
FORCE=false
CHECK_ONLY=false
DRY_RUN=false
VERBOSE=false

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[0;33m'
    readonly BLUE='\033[0;34m'
    readonly NC='\033[0m' # No Color
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly NC=''
fi

# ----------------------------------------------------------------------------
# Utility functions
# ----------------------------------------------------------------------------

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_verbose() {
    if [[ "${VERBOSE}" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $*"
    fi
}

show_help() {
    head -30 "${BASH_SOURCE[0]}" | tail -25 | sed 's/^# //' | sed 's/^#//'
}

# Check if a command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Create directory if it doesn't exist
ensure_dir() {
    local dir="$1"
    if [[ ! -d "${dir}" ]]; then
        if [[ "${DRY_RUN}" == "true" ]]; then
            log_info "Would create directory: ${dir}"
        else
            mkdir -p "${dir}"
            log_verbose "Created directory: ${dir}"
        fi
    fi
}

# Write file with dry-run support
write_file() {
    local path="$1"
    local content="$2"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Would write: ${path}"
        if [[ "${VERBOSE}" == "true" ]]; then
            echo "--- Content preview (first 20 lines) ---"
            echo "${content}" | head -20
            echo "---"
        fi
    else
        echo "${content}" > "${path}"
        log_verbose "Wrote: ${path}"
    fi
}

# ----------------------------------------------------------------------------
# YAML parsing (simple, without external dependencies)
# ----------------------------------------------------------------------------

# Extract a simple value from YAML (handles basic cases)
yaml_get() {
    local file="$1"
    local key="$2"
    grep -E "^${key}:" "${file}" 2>/dev/null | head -1 | sed "s/^${key}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//' | sed "s/^'//" | sed "s/'$//"
}

# Extract multiline value (for instructions.role, etc.)
yaml_get_block() {
    local file="$1"
    local key="$2"
    local in_block=false
    local indent=""
    local result=""

    while IFS= read -r line; do
        if [[ "${in_block}" == "true" ]]; then
            # Check if we've exited the block (less indentation or new key at same level)
            if [[ -n "${line}" && ! "${line}" =~ ^[[:space:]] ]]; then
                break
            fi
            if [[ -n "${line}" ]]; then
                # Remove the leading indentation
                result+="${line#${indent}}"$'\n'
            else
                result+=$'\n'
            fi
        elif [[ "${line}" =~ ^${key}:[[:space:]]*\|[[:space:]]*$ ]]; then
            in_block=true
            # Detect indentation from next non-empty line
            while IFS= read -r next_line; do
                if [[ -n "${next_line}" && "${next_line}" =~ ^([[:space:]]+) ]]; then
                    indent="${BASH_REMATCH[1]}"
                    result+="${next_line#${indent}}"$'\n'
                    break
                fi
            done
        fi
    done < "${file}"

    echo "${result}"
}

# Get list of items from YAML array
yaml_get_list() {
    local file="$1"
    local key="$2"
    local in_list=false

    while IFS= read -r line; do
        if [[ "${in_list}" == "true" ]]; then
            if [[ "${line}" =~ ^[[:space:]]+-[[:space:]]+(.*) ]]; then
                local item="${BASH_REMATCH[1]}"
                # Remove quotes if present
                item="${item#\"}"
                item="${item%\"}"
                item="${item#\'}"
                item="${item%\'}"
                echo "${item}"
            elif [[ -n "${line}" && ! "${line}" =~ ^[[:space:]] ]]; then
                break
            fi
        elif [[ "${line}" =~ ^${key}:[[:space:]]*$ ]]; then
            in_list=true
        fi
    done < "${file}"
}

# ----------------------------------------------------------------------------
# Version checking
# ----------------------------------------------------------------------------

get_current_version() {
    if [[ -f "${VERSION_FILE}" ]]; then
        cat "${VERSION_FILE}"
    else
        echo "0.0.0"
    fi
}

compute_skills_hash() {
    # Compute a hash of all skill files to detect changes
    if command_exists md5sum; then
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -exec cat {} \; 2>/dev/null | md5sum | cut -d' ' -f1
    elif command_exists md5; then
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -exec cat {} \; 2>/dev/null | md5
    else
        # Fallback: use file modification times
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -printf '%T@\n' 2>/dev/null | sort | tail -1
    fi
}

needs_regeneration() {
    local current_version
    local skills_hash

    current_version=$(get_current_version)
    skills_hash=$(compute_skills_hash)

    # Check if version file contains the current hash
    if [[ "${current_version}" != *"${skills_hash}"* ]]; then
        return 0  # Needs regeneration
    fi
    return 1  # Up to date
}

# ----------------------------------------------------------------------------
# Generator functions
# ----------------------------------------------------------------------------

# Collect all skill files
get_skill_files() {
    find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" | sort
}

# Generate the main AGENTS.md file
generate_agents_md() {
    log_info "Generating AGENTS.md..."

    local content
    content=$(cat << 'AGENTS_HEADER'
# Fundamental rules for AI agents

> This file follows the [AGENTS.md standard](https://agents.md/)
>
> ${GENERATED_MARKER} - Do not edit manually

## First mandatory action

1. **Read `.ai/MEMORY.md`** to load context and preferences
2. Run `.ai/generate.sh` if skills have been modified

## Rule 0: honesty

- Right to not know, to ask for clarification
- Never invent facts, never pretend
- Acknowledge uncertainty when present

## Rule 1: state of the art and consensus

- Consult official documentation before acting
- Search for solutions that have consensus on the internet
- Consult `.ai/sources.yaml` for reference URLs
- Prefer established patterns over novel approaches

## Rule 2: directed development

Order: specification -> documentation -> tests -> code -> refactoring

## Rule 3: security

- Never expose secrets (API keys, tokens, credentials)
- Principle of least privilege
- Validate inputs, escape outputs

## Rule 4: DRY and KISS

- Single source of truth (`.ai/skills/*.yaml`)
- Keep things simple
- Decompose into atomic tasks

## Rule 5: todo list

Format: `[ ]` to do, `[x]` done, `[~]` in progress, `[!]` blocked

## Rule 6: file organization

- `tmp/` for temporary files (gitignored)
- Never temporary files at root

## Rule 7: agent management

- Signal which agents are used: "Agent(s): [list]"
- AGENTS.md rules prevail over skill instructions

## Rule 8: self-improvement

- Propose updates if better practices detected
- Signal if instructions are obsolete

## Rule 9: checklist before commit

- [ ] `generate.sh` executed if skills modified
- [ ] `prompt-validator` passed if prompts modified
- [ ] `inclusivity-reviewer` passed if FR content modified
- [ ] `translator` sync check if docs modified
- [ ] `memory-keeper` invoked if important decisions made

## Rule 10: writing conventions and inclusivity

### Inclusive writing (French)

- Middle dot (·): expert·e, utilisateur·ice
- Epicene forms when possible
- Avoid ableist language

### Modern terminology

| Legacy | Modern |
|--------|--------|
| master/slave | primary/replica |
| whitelist/blacklist | allowlist/blocklist |
| master branch | main branch |

## Rule 11: persistent memory

- Read `.ai/MEMORY.md` at session start
- Update via `memory-keeper` after important decisions

## Rule 12: language

- Code: English
- Documentation: English (main) with French translation
- Cross-reference links between EN/FR docs

---

## Available skills

AGENTS_HEADER
)

    # Add skill list
    local skill_file
    for skill_file in $(get_skill_files); do
        local name description category
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        category=$(yaml_get "${skill_file}" "category")

        if [[ -n "${name}" ]]; then
            content+=$'\n'"| ${name} | ${description:-No description} | ${category:-other} |"
        fi
    done

    # Add table header before skills
    content=$(echo "${content}" | sed '/^## Available skills$/a\
\
| Skill | Description | Category |\
|-------|-------------|----------|')

    content+=$'\n\n'"---"$'\n\n'"*${GENERATED_MARKER}*"

    local agents_dir
    agents_dir=$(dirname "${AGENTS_MD}")
    ensure_dir "${agents_dir}"
    write_file "${AGENTS_MD}" "${content}"
    log_success "Generated AGENTS.md"
}

# Generate CLAUDE.md pointer file
generate_claude_md() {
    log_info "Generating CLAUDE.md..."

    local content
    content=$(cat << EOF
# Claude Code configuration

> See [AGENTS.md](./AGENTS.md) for the complete rules.
>
> ${GENERATED_MARKER}

This file exists for backward compatibility with Claude Code.
All configuration is centralized in AGENTS.md.

## Quick start

\`\`\`bash
# First action at session start
cat .ai/MEMORY.md

# If skills were modified
.ai/generate.sh
\`\`\`

## Available skills

EOF
)

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -n "${name}" ]]; then
            content+="- **${name}**: ${description:-No description}"$'\n'
        fi
    done

    write_file "${CLAUDE_MD}" "${content}"
    log_success "Generated CLAUDE.md"
}

# Generate Claude Code subagent files
generate_claude_agents() {
    log_info "Generating Claude Code subagents..."

    ensure_dir "${CLAUDE_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role guidelines
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")
        guidelines=$(yaml_get_list "${skill_file}" "guidelines")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${CLAUDE_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Role"$'\n\n'
            content+="${role}"$'\n'
        fi

        if [[ -n "${guidelines}" ]]; then
            content+="## Guidelines"$'\n\n'
            echo "${guidelines}" | while IFS= read -r line; do
                if [[ -n "${line}" ]]; then
                    content+="- ${line}"$'\n'
                fi
            done
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated Claude Code subagents"
}

# Generate .cursorrules file
generate_cursorrules() {
    log_info "Generating .cursorrules..."

    local content="# Cursor Rules"$'\n'
    content+="# ${GENERATED_MARKER}"$'\n\n'
    content+="## General rules"$'\n\n'
    content+="- Read .ai/MEMORY.md at session start"$'\n'
    content+="- Follow AGENTS.md guidelines"$'\n'
    content+="- Use inclusive writing for French content"$'\n\n'
    content+="## Available skills"$'\n\n'

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        content+="### ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="${role}"$'\n'
        fi

        content+=$'\n'
    done

    write_file "${CURSOR_RULES}" "${content}"
    log_success "Generated .cursorrules"
}

# Generate .continuerc.json
generate_continuerc() {
    log_info "Generating .continuerc.json..."

    local skills_json="["
    local first=true

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -z "${name}" ]]; then
            continue
        fi

        if [[ "${first}" != "true" ]]; then
            skills_json+=","
        fi
        first=false

        # Escape quotes in description
        description="${description//\"/\\\"}"

        skills_json+=$'\n'"    {"
        skills_json+=$'\n'"      \"name\": \"${name}\","
        skills_json+=$'\n'"      \"description\": \"${description:-No description}\""
        skills_json+=$'\n'"    }"
    done

    skills_json+=$'\n'"  ]"

    local content
    content=$(cat << EOF
{
  "_comment": "${GENERATED_MARKER}",
  "customCommands": ${skills_json}
}
EOF
)

    write_file "${CONTINUE_RC}" "${content}"
    log_success "Generated .continuerc.json"
}

# Generate .aider.conf.yml
generate_aider_conf() {
    log_info "Generating .aider.conf.yml..."

    local content="# ${GENERATED_MARKER}"$'\n\n'
    content+="# Aider configuration"$'\n'
    content+="# See: https://aider.chat/docs/config.html"$'\n\n'
    content+="read:"$'\n'
    content+="  - .ai/MEMORY.md"$'\n'
    content+="  - AGENTS.md"$'\n\n'
    content+="# Conventions from skills"$'\n'
    content+="conventions: |"$'\n'
    content+="  Follow AGENTS.md rules."$'\n'
    content+="  Use inclusive writing for French content."$'\n'
    content+="  Check .ai/MEMORY.md for project context."$'\n\n'
    content+="# Available skills:"$'\n'

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -n "${name}" ]]; then
            content+="#   - ${name}: ${description:-No description}"$'\n'
        fi
    done

    write_file "${AIDER_CONF}" "${content}"
    log_success "Generated .aider.conf.yml"
}

# Generate Ollama Modelfiles
generate_ollama_modelfiles() {
    log_info "Generating Ollama Modelfiles..."

    ensure_dir "${OLLAMA_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role model
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        # Try to get Ollama-specific model, default to llama3.2
        model="llama3.2"

        local modelfile="${OLLAMA_DIR}/Modelfile.${name}"
        local content="# ${GENERATED_MARKER}"$'\n'
        content+="# Skill: ${name}"$'\n\n'
        content+="FROM ${model}"$'\n\n'
        content+="PARAMETER temperature 0.3"$'\n'
        content+="PARAMETER num_ctx 4096"$'\n\n'
        content+="SYSTEM \"\"\""$'\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="${role}"
        fi

        content+=$'\n'"\"\"\""$'\n'

        write_file "${modelfile}" "${content}"
    done

    log_success "Generated Ollama Modelfiles"
}

# Generate OpenCode agent files
generate_opencode_agents() {
    log_info "Generating OpenCode agents..."

    ensure_dir "${OPENCODE_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${OPENCODE_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Instructions"$'\n\n'
            content+="${role}"$'\n'
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated OpenCode agents"
}

# Generate Codex agent files
generate_codex_agents() {
    log_info "Generating Codex agents..."

    ensure_dir "${CODEX_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${CODEX_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Role"$'\n\n'
            content+="${role}"$'\n'
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated Codex agents"
}

# Update VERSION file
update_version() {
    local skills_hash
    skills_hash=$(compute_skills_hash)
    local version="1.0.0-${skills_hash}"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Would update VERSION to: ${version}"
    else
        echo "${version}" > "${VERSION_FILE}"
        log_success "Updated VERSION: ${version}"
    fi
}

# ----------------------------------------------------------------------------
# Main execution
# ----------------------------------------------------------------------------

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                FORCE=true
                shift
                ;;
            --check)
                CHECK_ONLY=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    log_info "Meta-prompt-LLM configuration generator"
    log_info "Project root: ${PROJECT_ROOT}"

    # Check if skills directory exists
    if [[ ! -d "${SKILLS_DIR}" ]]; then
        log_error "Skills directory not found: ${SKILLS_DIR}"
        exit 1
    fi

    # Count skill files
    local skill_count
    skill_count=$(get_skill_files | wc -l)
    log_info "Found ${skill_count} skill files"

    if [[ "${skill_count}" -eq 0 ]]; then
        log_warn "No skill files found in ${SKILLS_DIR}"
        log_warn "Skipping generation"
        exit 0
    fi

    # Check if regeneration is needed
    if [[ "${FORCE}" != "true" ]] && ! needs_regeneration; then
        log_success "Already up to date (use --force to regenerate)"
        if [[ "${CHECK_ONLY}" == "true" ]]; then
            exit 0
        fi
        return 0
    fi

    if [[ "${CHECK_ONLY}" == "true" ]]; then
        log_warn "Regeneration needed"
        exit 1
    fi

    # Run all generators
    generate_agents_md
    generate_claude_md
    generate_claude_agents
    generate_cursorrules
    generate_continuerc
    generate_aider_conf
    generate_ollama_modelfiles
    generate_opencode_agents
    generate_codex_agents

    # Update version
    update_version

    log_success "Generation complete!"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "(Dry run - no files were written)"
    fi
}

main "$@"
