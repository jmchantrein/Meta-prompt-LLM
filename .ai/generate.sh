#!/usr/bin/env bash
# ============================================================================
# generate.sh - Multi-platform configuration generator
# ============================================================================
# Generates platform-specific configuration files from .ai/skills/*.yaml
#
# Supported platforms:
#   - AGENTS.md (standard)
#   - CLAUDE.md (Claude Code)
#   - .claude/agents/*.md (Claude Code subagents)
#   - .cursorrules (Cursor)
#   - .continuerc.json (Continue.dev)
#   - .aider.conf.yml (Aider)
#   - ollama/Modelfile.* (Ollama)
#   - .opencode/agents/*.md (OpenCode)
#   - .codex/agents/*.md (Codex CLI)
#
# Usage:
#   ./generate.sh [OPTIONS]
#
# Options:
#   --force     Force regeneration even if VERSION unchanged
#   --check     Check if regeneration is needed (exit 1 if yes)
#   --dry-run   Show what would be generated without writing
#   --verbose   Show detailed output
#   --help      Show this help message
#
# ============================================================================

set -euo pipefail

# ----------------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------------
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly SKILLS_DIR="${SCRIPT_DIR}/skills"
readonly VERSION_FILE="${SCRIPT_DIR}/VERSION"
readonly GENERATED_MARKER="Auto-generated by generate.sh"

# Platform output paths
readonly AGENTS_MD="${PROJECT_ROOT}/AGENTS.md"
readonly CLAUDE_MD="${PROJECT_ROOT}/CLAUDE.md"
readonly CLAUDE_AGENTS_DIR="${PROJECT_ROOT}/.claude/agents"
readonly CURSOR_RULES="${PROJECT_ROOT}/.cursorrules"
readonly CONTINUE_RC="${PROJECT_ROOT}/.continuerc.json"
readonly AIDER_CONF="${PROJECT_ROOT}/.aider.conf.yml"
readonly OLLAMA_DIR="${PROJECT_ROOT}/ollama"
readonly OPENCODE_AGENTS_DIR="${PROJECT_ROOT}/.opencode/agents"
readonly CODEX_AGENTS_DIR="${PROJECT_ROOT}/.codex/agents"
readonly HOOKS_FILE="${SCRIPT_DIR}/hooks/hooks.yaml"
readonly CLAUDE_SETTINGS="${PROJECT_ROOT}/.claude/settings.json"

# Options
FORCE=false
CHECK_ONLY=false
DRY_RUN=false
VERBOSE=false

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[0;33m'
    readonly BLUE='\033[0;34m'
    readonly NC='\033[0m' # No Color
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly NC=''
fi

# ----------------------------------------------------------------------------
# Utility functions
# ----------------------------------------------------------------------------

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_verbose() {
    if [[ "${VERBOSE}" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $*"
    fi
}

show_help() {
    head -30 "${BASH_SOURCE[0]}" | tail -25 | sed 's/^# //' | sed 's/^#//'
}

# Check if a command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Create directory if it doesn't exist
ensure_dir() {
    local dir="$1"
    if [[ ! -d "${dir}" ]]; then
        if [[ "${DRY_RUN}" == "true" ]]; then
            log_info "Would create directory: ${dir}"
        else
            mkdir -p "${dir}"
            log_verbose "Created directory: ${dir}"
        fi
    fi
}

# Write file with dry-run support
write_file() {
    local path="$1"
    local content="$2"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Would write: ${path}"
        if [[ "${VERBOSE}" == "true" ]]; then
            echo "--- Content preview (first 20 lines) ---"
            echo "${content}" | head -20
            echo "---"
        fi
    else
        echo "${content}" > "${path}"
        log_verbose "Wrote: ${path}"
    fi
}

# ----------------------------------------------------------------------------
# YAML parsing (simple, without external dependencies)
# ----------------------------------------------------------------------------

# Extract a simple value from YAML (handles basic cases)
yaml_get() {
    local file="$1"
    local key="$2"
    grep -E "^${key}:" "${file}" 2>/dev/null | head -1 | sed "s/^${key}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//' | sed "s/^'//" | sed "s/'$//"
}

# Extract multiline value (for instructions.role, etc.)
yaml_get_block() {
    local file="$1"
    local key="$2"
    local in_block=false
    local indent=""
    local result=""

    while IFS= read -r line; do
        if [[ "${in_block}" == "true" ]]; then
            # Check if we've exited the block (less indentation or new key at same level)
            if [[ -n "${line}" && ! "${line}" =~ ^[[:space:]] ]]; then
                break
            fi
            if [[ -n "${line}" ]]; then
                # Remove the leading indentation
                result+="${line#${indent}}"$'\n'
            else
                result+=$'\n'
            fi
        elif [[ "${line}" =~ ^${key}:[[:space:]]*\|[[:space:]]*$ ]]; then
            in_block=true
            # Detect indentation from next non-empty line
            while IFS= read -r next_line; do
                if [[ -n "${next_line}" && "${next_line}" =~ ^([[:space:]]+) ]]; then
                    indent="${BASH_REMATCH[1]}"
                    result+="${next_line#${indent}}"$'\n'
                    break
                fi
            done
        fi
    done < "${file}"

    echo "${result}"
}

# Get list of items from YAML array
yaml_get_list() {
    local file="$1"
    local key="$2"
    local in_list=false

    while IFS= read -r line; do
        if [[ "${in_list}" == "true" ]]; then
            if [[ "${line}" =~ ^[[:space:]]+-[[:space:]]+(.*) ]]; then
                local item="${BASH_REMATCH[1]}"
                # Remove quotes if present
                item="${item#\"}"
                item="${item%\"}"
                item="${item#\'}"
                item="${item%\'}"
                echo "${item}"
            elif [[ -n "${line}" && ! "${line}" =~ ^[[:space:]] ]]; then
                break
            fi
        elif [[ "${line}" =~ ^${key}:[[:space:]]*$ ]]; then
            in_list=true
        fi
    done < "${file}"
}

# ----------------------------------------------------------------------------
# Version checking
# ----------------------------------------------------------------------------

get_current_version() {
    if [[ -f "${VERSION_FILE}" ]]; then
        cat "${VERSION_FILE}"
    else
        echo "0.0.0"
    fi
}

compute_skills_hash() {
    # Compute a hash of all skill files to detect changes
    if command_exists md5sum; then
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -exec cat {} \; 2>/dev/null | md5sum | cut -d' ' -f1
    elif command_exists md5; then
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -exec cat {} \; 2>/dev/null | md5
    else
        # Fallback: use file modification times
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -printf '%T@\n' 2>/dev/null | sort | tail -1
    fi
}

needs_regeneration() {
    local current_version
    local skills_hash

    current_version=$(get_current_version)
    skills_hash=$(compute_skills_hash)

    # Check if version file contains the current hash
    if [[ "${current_version}" != *"${skills_hash}"* ]]; then
        return 0  # Needs regeneration
    fi
    return 1  # Up to date
}

# ----------------------------------------------------------------------------
# Generator functions
# ----------------------------------------------------------------------------

# Collect all skill files
get_skill_files() {
    find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" | sort
}

# Generate the main AGENTS.md file
generate_agents_md() {
    log_info "Generating AGENTS.md..."

    local content
    content=$(cat << 'AGENTS_HEADER'
# Fundamental rules for AI agents

> This file follows the [AGENTS.md standard](https://agents.md/)
>
> ${GENERATED_MARKER} - Do not edit manually

## First mandatory action

1. **Read `.ai/MEMORY.md`** to load context and preferences
2. Run `.ai/generate.sh` if skills have been modified

## Rule 0: honesty

- Right to not know, to ask for clarification
- Never invent facts, never pretend
- Acknowledge uncertainty when present

## Rule 1: state of the art and consensus

- Consult official documentation before acting
- Search for solutions that have consensus on the internet
- Consult `.ai/sources.yaml` for reference URLs
- Prefer established patterns over novel approaches

## Rule 2: directed development

Order: specification -> documentation -> tests -> code -> refactoring

## Rule 3: security

- Never expose secrets (API keys, tokens, credentials)
- Principle of least privilege
- Validate inputs, escape outputs

## Rule 4: DRY and KISS

- Single source of truth (`prompts/fr/metametaprompts/data/`)
- Keep things simple
- Decompose into atomic tasks

## Rule 5: todo list

Format: `[ ]` to do, `[x]` done, `[~]` in progress, `[!]` blocked

## Rule 6: file organization

- `tmp/` for temporary files (gitignored)
- Never temporary files at root

## Rule 7: agent management

- Signal which agents are used: "Agent(s): [list]"
- AGENTS.md rules prevail over skill instructions

## Rule 8: self-improvement

- Propose updates if better practices detected
- Signal if instructions are obsolete

## Rule 9: checklist before commit

- [ ] `generate.sh` executed if skills modified
- [ ] `prompt-validator` passed if prompts modified
- [ ] `inclusivity-reviewer` passed if FR content modified
- [ ] `translator` sync check if docs modified
- [ ] `link-checker` passed if markdown files modified
- [ ] `memory-keeper` invoked if important decisions made

## Rule 10: writing conventions and inclusivity

### Inclusive writing (French)

- Middle dot (·): expert·e, utilisateur·ice
- Epicene forms when possible
- Avoid ableist language

### Modern terminology

| Legacy | Modern |
|--------|--------|
| master/slave | primary/replica |
| whitelist/blacklist | allowlist/blocklist |
| master branch | main branch |

## Rule 11: persistent memory

- Read `.ai/MEMORY.md` at session start
- Update via `memory-keeper` after important decisions

## Rule 12: language

- Code: English
- Documentation: English (main) with French translation
- Cross-reference links between EN/FR docs

## Rule 13: version check

At session start, if this prompt has a META block:

1. Read \`source_url\` and \`version\` from META
2. Fetch source (if web access available)
3. Compare local version with remote version
4. If remote is newer: inform user, show changelog, propose update
5. If same or no web access: continue normally

---

## Available skills

AGENTS_HEADER
)

    # Add skill list
    local skill_file
    for skill_file in $(get_skill_files); do
        local name description category
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        category=$(yaml_get "${skill_file}" "category")

        if [[ -n "${name}" ]]; then
            content+=$'\n'"| ${name} | ${description:-No description} | ${category:-other} |"
        fi
    done

    # Add table header before skills
    content=$(echo "${content}" | sed '/^## Available skills$/a\
\
| Skill | Description | Category |\
|-------|-------------|----------|')

    content+=$'\n\n'"---"$'\n\n'"*${GENERATED_MARKER}*"

    local agents_dir
    agents_dir=$(dirname "${AGENTS_MD}")
    ensure_dir "${agents_dir}"
    write_file "${AGENTS_MD}" "${content}"
    log_success "Generated AGENTS.md"
}

# Generate CLAUDE.md pointer file
generate_claude_md() {
    log_info "Generating CLAUDE.md..."

    local content
    content=$(cat << EOF
# Claude Code configuration

> See [AGENTS.md](./AGENTS.md) for the complete rules.
>
> ${GENERATED_MARKER}

This file exists for backward compatibility with Claude Code.
All configuration is centralized in AGENTS.md.

## Quick start

\`\`\`bash
# First action at session start
cat .ai/MEMORY.md

# If skills were modified
.ai/generate.sh
\`\`\`

## Available skills

EOF
)

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -n "${name}" ]]; then
            content+="- **${name}**: ${description:-No description}"$'\n'
        fi
    done

    write_file "${CLAUDE_MD}" "${content}"
    log_success "Generated CLAUDE.md"
}

# Generate Claude Code subagent files
generate_claude_agents() {
    log_info "Generating Claude Code subagents..."

    ensure_dir "${CLAUDE_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role guidelines
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")
        guidelines=$(yaml_get_list "${skill_file}" "guidelines")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${CLAUDE_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Role"$'\n\n'
            content+="${role}"$'\n'
        fi

        if [[ -n "${guidelines}" ]]; then
            content+="## Guidelines"$'\n\n'
            echo "${guidelines}" | while IFS= read -r line; do
                if [[ -n "${line}" ]]; then
                    content+="- ${line}"$'\n'
                fi
            done
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated Claude Code subagents"
}

# Generate .cursorrules file
generate_cursorrules() {
    log_info "Generating .cursorrules..."

    local content="# Cursor Rules"$'\n'
    content+="# ${GENERATED_MARKER}"$'\n\n'
    content+="## General rules"$'\n\n'
    content+="- Read .ai/MEMORY.md at session start"$'\n'
    content+="- Follow AGENTS.md guidelines"$'\n'
    content+="- Use inclusive writing for French content"$'\n\n'
    content+="## Available skills"$'\n\n'

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        content+="### ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="${role}"$'\n'
        fi

        content+=$'\n'
    done

    write_file "${CURSOR_RULES}" "${content}"
    log_success "Generated .cursorrules"
}

# Generate .continuerc.json
generate_continuerc() {
    log_info "Generating .continuerc.json..."

    local skills_json="["
    local first=true

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -z "${name}" ]]; then
            continue
        fi

        if [[ "${first}" != "true" ]]; then
            skills_json+=","
        fi
        first=false

        # Escape quotes in description
        description="${description//\"/\\\"}"

        skills_json+=$'\n'"    {"
        skills_json+=$'\n'"      \"name\": \"${name}\","
        skills_json+=$'\n'"      \"description\": \"${description:-No description}\""
        skills_json+=$'\n'"    }"
    done

    skills_json+=$'\n'"  ]"

    local content
    content=$(cat << EOF
{
  "_comment": "${GENERATED_MARKER}",
  "customCommands": ${skills_json}
}
EOF
)

    write_file "${CONTINUE_RC}" "${content}"
    log_success "Generated .continuerc.json"
}

# Generate .aider.conf.yml
generate_aider_conf() {
    log_info "Generating .aider.conf.yml..."

    local content="# ${GENERATED_MARKER}"$'\n\n'
    content+="# Aider configuration"$'\n'
    content+="# See: https://aider.chat/docs/config.html"$'\n\n'
    content+="read:"$'\n'
    content+="  - .ai/MEMORY.md"$'\n'
    content+="  - AGENTS.md"$'\n\n'
    content+="# Conventions from skills"$'\n'
    content+="conventions: |"$'\n'
    content+="  Follow AGENTS.md rules."$'\n'
    content+="  Use inclusive writing for French content."$'\n'
    content+="  Check .ai/MEMORY.md for project context."$'\n\n'
    content+="# Available skills:"$'\n'

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -n "${name}" ]]; then
            content+="#   - ${name}: ${description:-No description}"$'\n'
        fi
    done

    write_file "${AIDER_CONF}" "${content}"
    log_success "Generated .aider.conf.yml"
}

# Generate Ollama Modelfiles
generate_ollama_modelfiles() {
    log_info "Generating Ollama Modelfiles..."

    ensure_dir "${OLLAMA_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role model
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        # Try to get Ollama-specific model, default to llama3.2
        model="llama3.2"

        local modelfile="${OLLAMA_DIR}/Modelfile.${name}"
        local content="# ${GENERATED_MARKER}"$'\n'
        content+="# Skill: ${name}"$'\n\n'
        content+="FROM ${model}"$'\n\n'
        content+="PARAMETER temperature 0.3"$'\n'
        content+="PARAMETER num_ctx 4096"$'\n\n'
        content+="SYSTEM \"\"\""$'\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="${role}"
        fi

        content+=$'\n'"\"\"\""$'\n'

        write_file "${modelfile}" "${content}"
    done

    log_success "Generated Ollama Modelfiles"
}

# Generate OpenCode agent files
generate_opencode_agents() {
    log_info "Generating OpenCode agents..."

    ensure_dir "${OPENCODE_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${OPENCODE_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Instructions"$'\n\n'
            content+="${role}"$'\n'
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated OpenCode agents"
}

# Generate Codex agent files
generate_codex_agents() {
    log_info "Generating Codex agents..."

    ensure_dir "${CODEX_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${CODEX_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Role"$'\n\n'
            content+="${role}"$'\n'
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated Codex agents"
}

# Generate Claude Code hooks settings
generate_claude_hooks() {
    log_info "Generating Claude Code hooks..."

    if [[ ! -f "${HOOKS_FILE}" ]]; then
        log_warn "Hooks file not found: ${HOOKS_FILE}"
        log_warn "Skipping hooks generation"
        return 0
    fi

    ensure_dir "$(dirname "${CLAUDE_SETTINGS}")"

    # Generate hooks JSON from YAML
    # This is a simplified parser that extracts enabled hooks
    local hooks_json='{'
    hooks_json+='"_comment": "'"${GENERATED_MARKER}"' from .ai/hooks/hooks.yaml",'
    hooks_json+='"hooks": {'

    local has_pre_tool=false
    local has_post_tool=false
    local has_user_prompt=false
    local has_stop=false

    local pre_tool_hooks=""
    local post_tool_hooks=""
    local user_prompt_hooks=""
    local stop_hooks=""

    local current_section=""
    local current_event=""
    local in_hook=false
    local hook_enabled=false
    local hook_matcher=""
    local hook_type=""
    local hook_command=""
    local hook_prompt=""

    while IFS= read -r line; do
        # Detect section changes
        if [[ "${line}" =~ ^(session|guardrails|automation|audit|session_end|validation): ]]; then
            current_section="${BASH_REMATCH[1]}"
            continue
        fi

        # Detect lifecycle event
        if [[ "${line}" =~ ^[[:space:]]+(PreToolUse|PostToolUse|UserPromptSubmit|Stop): ]]; then
            current_event="${BASH_REMATCH[1]}"
            continue
        fi

        # Detect hook start
        if [[ "${line}" =~ ^[[:space:]]+-[[:space:]]+name:[[:space:]]*\"([^\"]+)\" ]]; then
            # Save previous hook if it was enabled
            if [[ "${in_hook}" == "true" && "${hook_enabled}" == "true" ]]; then
                local hook_json=""
                if [[ -n "${hook_matcher}" ]]; then
                    hook_json='{"matcher":"'"${hook_matcher}"'","hooks":[{"type":"'"${hook_type}"'"'
                else
                    hook_json='{"hooks":[{"type":"'"${hook_type}"'"'
                fi

                if [[ "${hook_type}" == "command" && -n "${hook_command}" ]]; then
                    # Escape special chars in command
                    local escaped_cmd="${hook_command//\\/\\\\}"
                    escaped_cmd="${escaped_cmd//\"/\\\"}"
                    escaped_cmd="${escaped_cmd//$'\n'/\\n}"
                    hook_json+=',"command":"'"${escaped_cmd}"'"'
                elif [[ "${hook_type}" == "prompt" && -n "${hook_prompt}" ]]; then
                    local escaped_prompt="${hook_prompt//\"/\\\"}"
                    hook_json+=',"prompt":"'"${escaped_prompt}"'"'
                fi
                hook_json+='}]}'

                case "${current_event}" in
                    PreToolUse)
                        [[ "${has_pre_tool}" == "true" ]] && pre_tool_hooks+=","
                        pre_tool_hooks+="${hook_json}"
                        has_pre_tool=true
                        ;;
                    PostToolUse)
                        [[ "${has_post_tool}" == "true" ]] && post_tool_hooks+=","
                        post_tool_hooks+="${hook_json}"
                        has_post_tool=true
                        ;;
                    UserPromptSubmit)
                        [[ "${has_user_prompt}" == "true" ]] && user_prompt_hooks+=","
                        user_prompt_hooks+="${hook_json}"
                        has_user_prompt=true
                        ;;
                    Stop)
                        [[ "${has_stop}" == "true" ]] && stop_hooks+=","
                        stop_hooks+="${hook_json}"
                        has_stop=true
                        ;;
                esac
            fi

            # Start new hook
            in_hook=true
            hook_enabled=false
            hook_matcher=""
            hook_type=""
            hook_command=""
            hook_prompt=""
            continue
        fi

        # Parse hook properties
        if [[ "${in_hook}" == "true" ]]; then
            if [[ "${line}" =~ enabled:[[:space:]]*(true|false) ]]; then
                [[ "${BASH_REMATCH[1]}" == "true" ]] && hook_enabled=true
            elif [[ "${line}" =~ matcher:[[:space:]]*\"([^\"]+)\" ]]; then
                hook_matcher="${BASH_REMATCH[1]}"
            elif [[ "${line}" =~ -[[:space:]]+type:[[:space:]]*\"(command|prompt|agent)\" ]]; then
                hook_type="${BASH_REMATCH[1]}"
            elif [[ "${line}" =~ command:[[:space:]]*\| ]]; then
                # Multiline command - read next lines
                hook_command=""
                while IFS= read -r cmd_line; do
                    if [[ "${cmd_line}" =~ ^[[:space:]]{12,} ]]; then
                        hook_command+="${cmd_line#            }"$'\n'
                    else
                        break
                    fi
                done
                hook_command="${hook_command%$'\n'}"
            elif [[ "${line}" =~ prompt:[[:space:]]*\"([^\"]+)\" ]]; then
                hook_prompt="${BASH_REMATCH[1]}"
            fi
        fi
    done < "${HOOKS_FILE}"

    # Handle last hook
    if [[ "${in_hook}" == "true" && "${hook_enabled}" == "true" ]]; then
        local hook_json=""
        if [[ -n "${hook_matcher}" ]]; then
            hook_json='{"matcher":"'"${hook_matcher}"'","hooks":[{"type":"'"${hook_type}"'"'
        else
            hook_json='{"hooks":[{"type":"'"${hook_type}"'"'
        fi

        if [[ "${hook_type}" == "command" && -n "${hook_command}" ]]; then
            local escaped_cmd="${hook_command//\\/\\\\}"
            escaped_cmd="${escaped_cmd//\"/\\\"}"
            escaped_cmd="${escaped_cmd//$'\n'/\\n}"
            hook_json+=',"command":"'"${escaped_cmd}"'"'
        elif [[ "${hook_type}" == "prompt" && -n "${hook_prompt}" ]]; then
            local escaped_prompt="${hook_prompt//\"/\\\"}"
            hook_json+=',"prompt":"'"${escaped_prompt}"'"'
        fi
        hook_json+='}]}'

        case "${current_event}" in
            PreToolUse)
                [[ "${has_pre_tool}" == "true" ]] && pre_tool_hooks+=","
                pre_tool_hooks+="${hook_json}"
                has_pre_tool=true
                ;;
            PostToolUse)
                [[ "${has_post_tool}" == "true" ]] && post_tool_hooks+=","
                post_tool_hooks+="${hook_json}"
                has_post_tool=true
                ;;
            UserPromptSubmit)
                [[ "${has_user_prompt}" == "true" ]] && user_prompt_hooks+=","
                user_prompt_hooks+="${hook_json}"
                has_user_prompt=true
                ;;
            Stop)
                [[ "${has_stop}" == "true" ]] && stop_hooks+=","
                stop_hooks+="${hook_json}"
                has_stop=true
                ;;
        esac
    fi

    # Build final JSON
    local first_event=true
    if [[ "${has_user_prompt}" == "true" ]]; then
        [[ "${first_event}" != "true" ]] && hooks_json+=","
        hooks_json+='"UserPromptSubmit":['"${user_prompt_hooks}"']'
        first_event=false
    fi
    if [[ "${has_pre_tool}" == "true" ]]; then
        [[ "${first_event}" != "true" ]] && hooks_json+=","
        hooks_json+='"PreToolUse":['"${pre_tool_hooks}"']'
        first_event=false
    fi
    if [[ "${has_post_tool}" == "true" ]]; then
        [[ "${first_event}" != "true" ]] && hooks_json+=","
        hooks_json+='"PostToolUse":['"${post_tool_hooks}"']'
        first_event=false
    fi
    if [[ "${has_stop}" == "true" ]]; then
        [[ "${first_event}" != "true" ]] && hooks_json+=","
        hooks_json+='"Stop":['"${stop_hooks}"']'
        first_event=false
    fi

    hooks_json+='}}'

    # Format JSON if jq is available
    if command_exists jq; then
        hooks_json=$(echo "${hooks_json}" | jq '.')
    fi

    write_file "${CLAUDE_SETTINGS}" "${hooks_json}"
    log_success "Generated Claude Code hooks settings"
}

# Update VERSION file
update_version() {
    local skills_hash
    skills_hash=$(compute_skills_hash)
    local version="1.0.0-${skills_hash}"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Would update VERSION to: ${version}"
    else
        echo "${version}" > "${VERSION_FILE}"
        log_success "Updated VERSION: ${version}"
    fi
}

# ----------------------------------------------------------------------------
# Main execution
# ----------------------------------------------------------------------------

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                FORCE=true
                shift
                ;;
            --check)
                CHECK_ONLY=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    log_info "Meta-prompt-LLM configuration generator"
    log_info "Project root: ${PROJECT_ROOT}"

    # Check if skills directory exists
    if [[ ! -d "${SKILLS_DIR}" ]]; then
        log_error "Skills directory not found: ${SKILLS_DIR}"
        exit 1
    fi

    # Count skill files
    local skill_count
    skill_count=$(get_skill_files | wc -l)
    log_info "Found ${skill_count} skill files"

    if [[ "${skill_count}" -eq 0 ]]; then
        log_warn "No skill files found in ${SKILLS_DIR}"
        log_warn "Skipping generation"
        exit 0
    fi

    # Check if regeneration is needed
    if [[ "${FORCE}" != "true" ]] && ! needs_regeneration; then
        log_success "Already up to date (use --force to regenerate)"
        if [[ "${CHECK_ONLY}" == "true" ]]; then
            exit 0
        fi
        return 0
    fi

    if [[ "${CHECK_ONLY}" == "true" ]]; then
        log_warn "Regeneration needed"
        exit 1
    fi

    # Run all generators
    generate_agents_md
    generate_claude_md
    generate_claude_agents
    generate_claude_hooks
    generate_cursorrules
    generate_continuerc
    generate_aider_conf
    generate_ollama_modelfiles
    generate_opencode_agents
    generate_codex_agents

    # Update version
    update_version

    log_success "Generation complete!"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "(Dry run - no files were written)"
    fi
}

main "$@"
