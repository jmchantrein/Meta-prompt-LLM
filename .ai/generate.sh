#!/usr/bin/env bash
# ============================================================================
# generate.sh - Multi-platform configuration generator
# ============================================================================
# Generates platform-specific configuration files from .ai/skills/*.yaml
#
# Supported platforms:
#   - AGENTS.md (standard)
#   - CLAUDE.md (Claude Code)
#   - .claude/agents/*.md (Claude Code subagents)
#   - .cursorrules (Cursor)
#   - .continuerc.json (Continue.dev)
#   - .aider.conf.yml (Aider)
#   - ollama/Modelfile.* (Ollama)
#   - .opencode/agents/*.md (OpenCode)
#   - .codex/agents/*.md (Codex CLI)
#
# Usage:
#   ./generate.sh [OPTIONS]
#
# Options:
#   --force     Force regeneration even if VERSION unchanged
#   --check     Check if regeneration is needed (exit 1 if yes)
#   --dry-run   Show what would be generated without writing
#   --verbose   Show detailed output
#   --help      Show this help message
#
# ============================================================================

set -euo pipefail

# ----------------------------------------------------------------------------
# Configuration
# ----------------------------------------------------------------------------
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly SKILLS_DIR="${SCRIPT_DIR}/skills"
readonly VERSION_FILE="${SCRIPT_DIR}/VERSION"
readonly GENERATED_MARKER="Auto-generated by generate.sh"

# Platform output paths
readonly AGENTS_MD="${PROJECT_ROOT}/AGENTS.md"
readonly CLAUDE_MD="${PROJECT_ROOT}/CLAUDE.md"
readonly CLAUDE_AGENTS_DIR="${PROJECT_ROOT}/.claude/agents"
readonly CURSOR_RULES="${PROJECT_ROOT}/.cursorrules"
readonly CURSOR_HOOKS="${PROJECT_ROOT}/.cursor/hooks.json"
readonly CONTINUE_RC="${PROJECT_ROOT}/.continuerc.json"
readonly AIDER_CONF="${PROJECT_ROOT}/.aider.conf.yml"
readonly OLLAMA_DIR="${PROJECT_ROOT}/ollama"
readonly OPENCODE_AGENTS_DIR="${PROJECT_ROOT}/.opencode/agents"
readonly OPENCODE_HOOKS_DIR="${PROJECT_ROOT}/.opencode/hooks"
readonly CODEX_AGENTS_DIR="${PROJECT_ROOT}/.codex/agents"
readonly CODEX_CONFIG="${PROJECT_ROOT}/codex.toml"
readonly HOOKS_FILE="${SCRIPT_DIR}/hooks/hooks.yaml"
readonly CLAUDE_SETTINGS="${PROJECT_ROOT}/.claude/settings.json"
readonly MEMORY_YAML="${PROJECT_ROOT}/prompts/fr/metametaprompts/data/memory/MEMORY.yaml"
readonly MEMORY_MD="${SCRIPT_DIR}/MEMORY.md"

# Data source paths (source of truth)
readonly DATA_DIR="${PROJECT_ROOT}/prompts/fr/metametaprompts/data"
readonly DATA_HOOKS_INTERNAL="${DATA_DIR}/hooks/internal"
readonly DATA_HOOKS_EXTERNAL="${DATA_DIR}/hooks/external"
readonly DATA_SKILLS_INTERNAL="${DATA_DIR}/skills/internal"
readonly DATA_SKILLS_EXTERNAL="${DATA_DIR}/skills/external"
readonly DATA_COMMANDS_INTERNAL="${DATA_DIR}/commands/internal"
readonly DATA_COMMANDS_EXTERNAL="${DATA_DIR}/commands/external"

# Options
FORCE=false
CHECK_ONLY=false
DRY_RUN=false
VERBOSE=false

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[0;33m'
    readonly BLUE='\033[0;34m'
    readonly NC='\033[0m' # No Color
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly NC=''
fi

# ----------------------------------------------------------------------------
# Utility functions
# ----------------------------------------------------------------------------

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_verbose() {
    if [[ "${VERBOSE}" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $*"
    fi
}

show_help() {
    head -30 "${BASH_SOURCE[0]}" | tail -25 | sed 's/^# //' | sed 's/^#//'
}

# Check if a command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Create directory if it doesn't exist
ensure_dir() {
    local dir="$1"
    if [[ ! -d "${dir}" ]]; then
        if [[ "${DRY_RUN}" == "true" ]]; then
            log_info "Would create directory: ${dir}"
        else
            mkdir -p "${dir}"
            log_verbose "Created directory: ${dir}"
        fi
    fi
}

# Write file with dry-run support
write_file() {
    local path="$1"
    local content="$2"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Would write: ${path}"
        if [[ "${VERBOSE}" == "true" ]]; then
            echo "--- Content preview (first 20 lines) ---"
            echo "${content}" | head -20
            echo "---"
        fi
    else
        echo "${content}" > "${path}"
        log_verbose "Wrote: ${path}"
    fi
}

# ----------------------------------------------------------------------------
# YAML parsing (simple, without external dependencies)
# ----------------------------------------------------------------------------

# Extract a simple value from YAML (handles basic cases)
yaml_get() {
    local file="$1"
    local key="$2"
    grep -E "^${key}:" "${file}" 2>/dev/null | head -1 | sed "s/^${key}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//' | sed "s/^'//" | sed "s/'$//"
}

# Extract multiline value (for instructions.role, etc.)
yaml_get_block() {
    local file="$1"
    local key="$2"
    local in_block=false
    local indent=""
    local result=""

    while IFS= read -r line; do
        if [[ "${in_block}" == "true" ]]; then
            # Check if we've exited the block (less indentation or new key at same level)
            if [[ -n "${line}" && ! "${line}" =~ ^[[:space:]] ]]; then
                break
            fi
            if [[ -n "${line}" ]]; then
                # Remove the leading indentation
                result+="${line#${indent}}"$'\n'
            else
                result+=$'\n'
            fi
        elif [[ "${line}" =~ ^${key}:[[:space:]]*\|[[:space:]]*$ ]]; then
            in_block=true
            # Detect indentation from next non-empty line
            while IFS= read -r next_line; do
                if [[ -n "${next_line}" && "${next_line}" =~ ^([[:space:]]+) ]]; then
                    indent="${BASH_REMATCH[1]}"
                    result+="${next_line#${indent}}"$'\n'
                    break
                fi
            done
        fi
    done < "${file}"

    echo "${result}"
}

# Get list of items from YAML array
yaml_get_list() {
    local file="$1"
    local key="$2"
    local in_list=false

    while IFS= read -r line; do
        if [[ "${in_list}" == "true" ]]; then
            if [[ "${line}" =~ ^[[:space:]]+-[[:space:]]+(.*) ]]; then
                local item="${BASH_REMATCH[1]}"
                # Remove quotes if present
                item="${item#\"}"
                item="${item%\"}"
                item="${item#\'}"
                item="${item%\'}"
                echo "${item}"
            elif [[ -n "${line}" && ! "${line}" =~ ^[[:space:]] ]]; then
                break
            fi
        elif [[ "${line}" =~ ^${key}:[[:space:]]*$ ]]; then
            in_list=true
        fi
    done < "${file}"
}

# ----------------------------------------------------------------------------
# Version checking
# ----------------------------------------------------------------------------

get_current_version() {
    if [[ -f "${VERSION_FILE}" ]]; then
        cat "${VERSION_FILE}"
    else
        echo "0.0.0"
    fi
}

compute_skills_hash() {
    # Compute a hash of all skill files to detect changes
    if command_exists md5sum; then
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -exec cat {} \; 2>/dev/null | md5sum | cut -d' ' -f1
    elif command_exists md5; then
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -exec cat {} \; 2>/dev/null | md5
    else
        # Fallback: use file modification times
        find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" -printf '%T@\n' 2>/dev/null | sort | tail -1
    fi
}

needs_regeneration() {
    local current_version
    local skills_hash

    current_version=$(get_current_version)
    skills_hash=$(compute_skills_hash)

    # Check if version file contains the current hash
    if [[ "${current_version}" != *"${skills_hash}"* ]]; then
        return 0  # Needs regeneration
    fi
    return 1  # Up to date
}

# ----------------------------------------------------------------------------
# Sync functions (copy from data/ to .ai/)
# ----------------------------------------------------------------------------

# Sync skills from data/skills/internal + external to .ai/skills/
sync_skills() {
    log_info "Syncing skills from data/..."
    ensure_dir "${SKILLS_DIR}"

    # Copy internal skills
    if [[ -d "${DATA_SKILLS_INTERNAL}" ]]; then
        for file in "${DATA_SKILLS_INTERNAL}"/*.yaml; do
            if [[ -f "${file}" ]]; then
                cp "${file}" "${SKILLS_DIR}/"
            fi
        done
    fi

    # Copy external skills (if any)
    if [[ -d "${DATA_SKILLS_EXTERNAL}" ]]; then
        for file in "${DATA_SKILLS_EXTERNAL}"/*.yaml; do
            if [[ -f "${file}" ]]; then
                cp "${file}" "${SKILLS_DIR}/"
            fi
        done
    fi

    log_success "Synced skills"
}

# Sync hooks from data/hooks/internal + external to .ai/hooks/
sync_hooks() {
    log_info "Syncing hooks from data/..."
    ensure_dir "${SCRIPT_DIR}/hooks"

    local output_file="${SCRIPT_DIR}/hooks/hooks.yaml"
    local content="# ${GENERATED_MARKER}"$'\n'
    content+="# Merged from data/hooks/internal/ + external/"$'\n\n'

    # Append internal hooks (main hooks.yaml)
    if [[ -f "${DATA_HOOKS_INTERNAL}/hooks.yaml" ]]; then
        # Skip the first lines if they're comments and add the rest
        content+="# === Internal hooks ==="$'\n'
        cat "${DATA_HOOKS_INTERNAL}/hooks.yaml" >> /dev/null  # Validate file exists
        content+=$(cat "${DATA_HOOKS_INTERNAL}/hooks.yaml")
        content+=$'\n\n'
    fi

    # Append external hooks (individual YAML files)
    if [[ -d "${DATA_HOOKS_EXTERNAL}" ]]; then
        local has_external=false
        for file in "${DATA_HOOKS_EXTERNAL}"/*.yaml; do
            if [[ -f "${file}" && "$(basename "${file}")" != ".gitkeep" ]]; then
                if [[ "${has_external}" == "false" ]]; then
                    content+="# === External hooks ==="$'\n'
                    has_external=true
                fi
                content+="# From: $(basename "${file}")"$'\n'
                content+=$(cat "${file}")
                content+=$'\n\n'
            fi
        done
    fi

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Would write hooks to: ${output_file}"
    else
        echo "${content}" > "${output_file}"
    fi

    log_success "Synced hooks"
}

# Sync commands from data/commands/internal + external to .ai/commands/
sync_commands() {
    log_info "Syncing commands from data/..."
    local commands_dir="${SCRIPT_DIR}/commands"
    ensure_dir "${commands_dir}"

    # Copy internal commands
    if [[ -d "${DATA_COMMANDS_INTERNAL}" ]]; then
        for file in "${DATA_COMMANDS_INTERNAL}"/*.yaml; do
            if [[ -f "${file}" && "$(basename "${file}")" != ".gitkeep" ]]; then
                cp "${file}" "${commands_dir}/"
            fi
        done
    fi

    # Copy external commands (if any)
    if [[ -d "${DATA_COMMANDS_EXTERNAL}" ]]; then
        for file in "${DATA_COMMANDS_EXTERNAL}"/*.yaml; do
            if [[ -f "${file}" && "$(basename "${file}")" != ".gitkeep" ]]; then
                cp "${file}" "${commands_dir}/"
            fi
        done
    fi

    log_success "Synced commands"
}

# ----------------------------------------------------------------------------
# Generator functions
# ----------------------------------------------------------------------------

# Collect all skill files
get_skill_files() {
    find "${SKILLS_DIR}" -name "*.yaml" -type f ! -name "_*" | sort
}

# Generate the main AGENTS.md file
generate_agents_md() {
    log_info "Generating AGENTS.md..."

    local content
    content=$(cat << 'AGENTS_HEADER'
# Fundamental rules for AI agents

> This file follows the [AGENTS.md standard](https://agents.md/)
>
> ${GENERATED_MARKER} - Do not edit manually

## First mandatory action

1. **Read `.ai/MEMORY.md`** to load context and preferences
2. Run `.ai/generate.sh` if skills have been modified

## Rule 0: honesty

- Right to not know, to ask for clarification
- Never invent facts, never pretend
- Acknowledge uncertainty when present

## Rule 1: state of the art and consensus

- Consult official documentation before acting
- Search for solutions that have consensus on the internet
- Consult `.ai/sources.yaml` for reference URLs
- Prefer established patterns over novel approaches

## Rule 2: directed development

Order: specification -> documentation -> tests -> code -> refactoring

## Rule 3: security

- Never expose secrets (API keys, tokens, credentials)
- Principle of least privilege
- Validate inputs, escape outputs

## Rule 4: DRY and KISS

- Single source of truth (`prompts/fr/metametaprompts/data/`)
- Keep things simple
- Decompose into atomic tasks

## Rule 5: todo list

Format: `[ ]` to do, `[x]` done, `[~]` in progress, `[!]` blocked

## Rule 6: file organization

- `tmp/` for temporary files (gitignored)
- Never temporary files at root

## Rule 7: agent management

- Signal which agents are used: "Agent(s): [list]"
- AGENTS.md rules prevail over skill instructions

## Rule 8: self-improvement

- Propose updates if better practices detected
- Signal if instructions are obsolete

## Rule 9: checklist before commit

- [ ] `generate.sh` executed if skills modified
- [ ] `prompt-validator` passed if prompts modified
- [ ] `inclusivity-reviewer` passed if FR content modified
- [ ] `translator` sync check if docs modified
- [ ] `link-checker` passed if markdown files modified
- [ ] `memory-keeper` invoked if important decisions made

## Rule 10: writing conventions and inclusivity

### Inclusive writing (French)

- Middle dot (Â·): expertÂ·e, utilisateurÂ·ice
- Epicene forms when possible
- Avoid ableist language

### Modern terminology

| Legacy | Modern |
|--------|--------|
| master/slave | primary/replica |
| whitelist/blacklist | allowlist/blocklist |
| master branch | main branch |

## Rule 11: persistent memory

- Read `.ai/MEMORY.md` at session start
- Update via `memory-keeper` after important decisions

## Rule 12: language

- Code: English
- Documentation: English (main) with French translation
- Cross-reference links between EN/FR docs

## Rule 13: version check

At session start, if this prompt has a META block:

1. Read \`source_url\` and \`version\` from META
2. Fetch source (if web access available)
3. Compare local version with remote version
4. If remote is newer: inform user, show changelog, propose update
5. If same or no web access: continue normally

---

## Available skills

AGENTS_HEADER
)

    # Add skill list
    local skill_file
    for skill_file in $(get_skill_files); do
        local name description category
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        category=$(yaml_get "${skill_file}" "category")

        if [[ -n "${name}" ]]; then
            content+=$'\n'"| ${name} | ${description:-No description} | ${category:-other} |"
        fi
    done

    # Add table header before skills
    content=$(echo "${content}" | sed '/^## Available skills$/a\
\
| Skill | Description | Category |\
|-------|-------------|----------|')

    content+=$'\n\n'"---"$'\n\n'"*${GENERATED_MARKER}*"

    local agents_dir
    agents_dir=$(dirname "${AGENTS_MD}")
    ensure_dir "${agents_dir}"
    write_file "${AGENTS_MD}" "${content}"
    log_success "Generated AGENTS.md"
}

# Generate CLAUDE.md pointer file
generate_claude_md() {
    log_info "Generating CLAUDE.md..."

    local content
    content=$(cat << EOF
# Claude Code configuration

> See [AGENTS.md](./AGENTS.md) for the complete rules.
>
> ${GENERATED_MARKER}

This file exists for backward compatibility with Claude Code.
All configuration is centralized in AGENTS.md.

## Quick start

\`\`\`bash
# First action at session start
cat .ai/MEMORY.md

# If skills were modified
.ai/generate.sh
\`\`\`

## Available skills

EOF
)

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -n "${name}" ]]; then
            content+="- **${name}**: ${description:-No description}"$'\n'
        fi
    done

    write_file "${CLAUDE_MD}" "${content}"
    log_success "Generated CLAUDE.md"
}

# Generate Claude Code subagent files
generate_claude_agents() {
    log_info "Generating Claude Code subagents..."

    ensure_dir "${CLAUDE_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role guidelines
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")
        guidelines=$(yaml_get_list "${skill_file}" "guidelines")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${CLAUDE_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Role"$'\n\n'
            content+="${role}"$'\n'
        fi

        if [[ -n "${guidelines}" ]]; then
            content+="## Guidelines"$'\n\n'
            echo "${guidelines}" | while IFS= read -r line; do
                if [[ -n "${line}" ]]; then
                    content+="- ${line}"$'\n'
                fi
            done
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated Claude Code subagents"
}

# Generate .cursorrules file
generate_cursorrules() {
    log_info "Generating .cursorrules..."

    local content="# Cursor Rules"$'\n'
    content+="# ${GENERATED_MARKER}"$'\n\n'
    content+="## General rules"$'\n\n'
    content+="- Read .ai/MEMORY.md at session start"$'\n'
    content+="- Follow AGENTS.md guidelines"$'\n'
    content+="- Use inclusive writing for French content"$'\n\n'
    content+="## Available skills"$'\n\n'

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        content+="### ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="${role}"$'\n'
        fi

        content+=$'\n'
    done

    write_file "${CURSOR_RULES}" "${content}"
    log_success "Generated .cursorrules"
}

# Generate Cursor hooks configuration
# Cursor hooks format: https://cursor.com/docs/agent/hooks
# Events: beforeSubmitPrompt, beforeShellExecution, beforeMCPExecution, beforeReadFile, afterFileEdit, stop
generate_cursor_hooks() {
    log_info "Generating Cursor hooks..."

    if [[ ! -f "${HOOKS_FILE}" ]]; then
        log_warn "Hooks file not found: ${HOOKS_FILE}"
        log_warn "Skipping Cursor hooks generation"
        return 0
    fi

    ensure_dir "$(dirname "${CURSOR_HOOKS}")"

    # Map Claude Code events to Cursor events
    # Claude Code -> Cursor:
    #   UserPromptSubmit -> beforeSubmitPrompt
    #   PreToolUse (Bash) -> beforeShellExecution
    #   PreToolUse (Read) -> beforeReadFile
    #   PostToolUse (Write/Edit) -> afterFileEdit
    #   Stop -> stop

    local hooks_json='{"$schema":"https://unpkg.com/cursor-hooks@latest/schema/hooks.schema.json","version":1,"hooks":{'
    local first_event=true

    # beforeSubmitPrompt - from UserPromptSubmit
    local beforeSubmit=""
    beforeSubmit=$(grep -A 50 "^UserPromptSubmit:" "${HOOKS_FILE}" 2>/dev/null | grep -E "command:" | head -1 | sed 's/.*command:[[:space:]]*//' | sed 's/^|.*//' | tr -d '"' | head -c 200)
    if [[ -n "${beforeSubmit}" && "${beforeSubmit}" != "|" ]]; then
        hooks_json+='"beforeSubmitPrompt":[{"command":"echo \"ðŸ“‹ Cursor: Prompt submitted\""}]'
        first_event=false
    fi

    # beforeShellExecution - from PreToolUse Bash
    if grep -q 'matcher:.*Bash' "${HOOKS_FILE}" 2>/dev/null; then
        [[ "${first_event}" != "true" ]] && hooks_json+=","
        hooks_json+='"beforeShellExecution":[{"command":"echo \"ðŸ”’ Cursor: Shell execution check\""}]'
        first_event=false
    fi

    # afterFileEdit - from PostToolUse Write
    if grep -q 'matcher:.*Write' "${HOOKS_FILE}" 2>/dev/null; then
        [[ "${first_event}" != "true" ]] && hooks_json+=","
        hooks_json+='"afterFileEdit":[{"command":"echo \"ðŸ“ Cursor: File edited\""}]'
        first_event=false
    fi

    # stop - from Stop event
    if grep -q "^Stop:" "${HOOKS_FILE}" 2>/dev/null; then
        [[ "${first_event}" != "true" ]] && hooks_json+=","
        hooks_json+='"stop":[{"command":"echo \"âœ… Cursor: Task completed\""}]'
        first_event=false
    fi

    hooks_json+='}}'

    # Format JSON if jq is available
    if command_exists jq; then
        hooks_json=$(echo "${hooks_json}" | jq '.' 2>/dev/null) || true
    fi

    write_file "${CURSOR_HOOKS}" "${hooks_json}"
    log_success "Generated Cursor hooks"
}

# Generate OpenCode hooks scripts
# OpenCode uses shell scripts in .opencode/hooks/ directory
generate_opencode_hooks() {
    log_info "Generating OpenCode hooks..."

    if [[ ! -f "${HOOKS_FILE}" ]]; then
        log_warn "Hooks file not found: ${HOOKS_FILE}"
        log_warn "Skipping OpenCode hooks generation"
        return 0
    fi

    ensure_dir "${OPENCODE_HOOKS_DIR}"

    # Create a general hook script for OpenCode
    local hook_script='#!/usr/bin/env bash
# '"${GENERATED_MARKER}"'
# OpenCode hook script - runs on various lifecycle events
# Place in .opencode/hooks/ and configure in oh-my-opencode.json

HOOK_EVENT="${1:-unknown}"

case "$HOOK_EVENT" in
    "chat.message")
        echo "ðŸ“‹ [OpenCode] Message received"
        ;;
    "session.create")
        echo "ðŸš€ [OpenCode] Session started"
        cat .ai/MEMORY.md 2>/dev/null || echo "No memory file found"
        ;;
    "session.error")
        echo "âŒ [OpenCode] Session error"
        ;;
    *)
        echo "â„¹ï¸ [OpenCode] Event: $HOOK_EVENT"
        ;;
esac
'

    write_file "${OPENCODE_HOOKS_DIR}/lifecycle.sh" "${hook_script}"

    # Make executable
    if [[ "${DRY_RUN}" != "true" ]]; then
        chmod +x "${OPENCODE_HOOKS_DIR}/lifecycle.sh" 2>/dev/null || true
    fi

    log_success "Generated OpenCode hooks"
}

# Generate Codex CLI configuration with notify
# Codex uses config.toml with notify option
generate_codex_config() {
    log_info "Generating Codex config..."

    local content='# '"${GENERATED_MARKER}"'
# Codex CLI configuration
# https://developers.openai.com/codex/config-reference/

[agent]
# Model configuration
model = "gpt-4"

[notifications]
# Notify on agent turn complete
# Currently the only supported event
notify = ["bash", "-c", "echo \"âœ… [Codex] Agent turn completed\""]

[context]
# Load project memory
auto_context = [".ai/MEMORY.md", "AGENTS.md"]

[sandbox]
# Enable sandbox mode for safety
enabled = true
'

    write_file "${CODEX_CONFIG}" "${content}"
    log_success "Generated Codex config"
}

# Generate .continuerc.json
generate_continuerc() {
    log_info "Generating .continuerc.json..."

    local skills_json="["
    local first=true

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -z "${name}" ]]; then
            continue
        fi

        if [[ "${first}" != "true" ]]; then
            skills_json+=","
        fi
        first=false

        # Escape quotes in description
        description="${description//\"/\\\"}"

        skills_json+=$'\n'"    {"
        skills_json+=$'\n'"      \"name\": \"${name}\","
        skills_json+=$'\n'"      \"description\": \"${description:-No description}\""
        skills_json+=$'\n'"    }"
    done

    skills_json+=$'\n'"  ]"

    local content
    content=$(cat << EOF
{
  "_comment": "${GENERATED_MARKER}",
  "customCommands": ${skills_json}
}
EOF
)

    write_file "${CONTINUE_RC}" "${content}"
    log_success "Generated .continuerc.json"
}

# Generate .aider.conf.yml
generate_aider_conf() {
    log_info "Generating .aider.conf.yml..."

    local content="# ${GENERATED_MARKER}"$'\n\n'
    content+="# Aider configuration"$'\n'
    content+="# See: https://aider.chat/docs/config.html"$'\n\n'
    content+="read:"$'\n'
    content+="  - .ai/MEMORY.md"$'\n'
    content+="  - AGENTS.md"$'\n\n'
    content+="# Conventions from skills"$'\n'
    content+="conventions: |"$'\n'
    content+="  Follow AGENTS.md rules."$'\n'
    content+="  Use inclusive writing for French content."$'\n'
    content+="  Check .ai/MEMORY.md for project context."$'\n\n'
    content+="# Available skills:"$'\n'

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")

        if [[ -n "${name}" ]]; then
            content+="#   - ${name}: ${description:-No description}"$'\n'
        fi
    done

    write_file "${AIDER_CONF}" "${content}"
    log_success "Generated .aider.conf.yml"
}

# Generate Ollama Modelfiles
generate_ollama_modelfiles() {
    log_info "Generating Ollama Modelfiles..."

    ensure_dir "${OLLAMA_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role model
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        # Try to get Ollama-specific model, default to llama3.2
        model="llama3.2"

        local modelfile="${OLLAMA_DIR}/Modelfile.${name}"
        local content="# ${GENERATED_MARKER}"$'\n'
        content+="# Skill: ${name}"$'\n\n'
        content+="FROM ${model}"$'\n\n'
        content+="PARAMETER temperature 0.3"$'\n'
        content+="PARAMETER num_ctx 4096"$'\n\n'
        content+="SYSTEM \"\"\""$'\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="${role}"
        fi

        content+=$'\n'"\"\"\""$'\n'

        write_file "${modelfile}" "${content}"
    done

    log_success "Generated Ollama Modelfiles"
}

# Generate OpenCode agent files
generate_opencode_agents() {
    log_info "Generating OpenCode agents..."

    ensure_dir "${OPENCODE_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${OPENCODE_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Instructions"$'\n\n'
            content+="${role}"$'\n'
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated OpenCode agents"
}

# Generate Codex agent files
generate_codex_agents() {
    log_info "Generating Codex agents..."

    ensure_dir "${CODEX_AGENTS_DIR}"

    local skill_file
    for skill_file in $(get_skill_files); do
        local name description role
        name=$(yaml_get "${skill_file}" "name")
        description=$(yaml_get "${skill_file}" "description")
        role=$(yaml_get_block "${skill_file}" "role")

        if [[ -z "${name}" ]]; then
            continue
        fi

        local agent_file="${CODEX_AGENTS_DIR}/${name}.md"
        local content="# ${name}"$'\n\n'
        content+="${description:-No description}"$'\n\n'

        if [[ -n "${role}" ]]; then
            content+="## Role"$'\n\n'
            content+="${role}"$'\n'
        fi

        content+=$'\n'"---"$'\n'"*${GENERATED_MARKER}*"$'\n'

        write_file "${agent_file}" "${content}"
    done

    log_success "Generated Codex agents"
}

# Generate Claude Code hooks settings
# Supports: SessionStart, UserPromptSubmit, PreToolUse, PostToolUse, Stop, SessionEnd
# Hook types: command, prompt, agent
generate_claude_hooks() {
    log_info "Generating Claude Code hooks..."

    if [[ ! -f "${HOOKS_FILE}" ]]; then
        log_warn "Hooks file not found: ${HOOKS_FILE}"
        log_warn "Skipping hooks generation"
        return 0
    fi

    ensure_dir "$(dirname "${CLAUDE_SETTINGS}")"

    # Temporary file for building JSON
    local tmp_file
    tmp_file=$(mktemp)
    trap "rm -f ${tmp_file}" EXIT

    # Initialize hook arrays for each event type
    declare -A event_hooks
    local ALL_EVENTS="SessionStart UserPromptSubmit PreToolUse PostToolUse Stop SessionEnd"
    for event in ${ALL_EVENTS}; do
        event_hooks["${event}"]=""
    done

    # State machine variables
    local current_event=""
    local in_hook_list=false
    local in_hook_item=false
    local hook_enabled=""
    local hook_matcher=""
    local hook_timeout=""
    local in_hooks_array=false
    local hook_type=""
    local hook_command=""
    local hook_prompt=""
    local reading_multiline=""
    local multiline_content=""
    local multiline_indent=0

    # Process YAML line by line
    while IFS= read -r line || [[ -n "${line}" ]]; do
        # Handle multiline content
        if [[ -n "${reading_multiline}" ]]; then
            # Check if line is still part of multiline (has sufficient indentation)
            local line_indent=0
            if [[ "${line}" =~ ^([[:space:]]*) ]]; then
                line_indent=${#BASH_REMATCH[1]}
            fi

            if [[ ${line_indent} -ge ${multiline_indent} && -n "${line}" ]] || [[ -z "${line// /}" ]]; then
                # Still in multiline, append content
                local content_part="${line}"
                if [[ ${line_indent} -ge ${multiline_indent} ]]; then
                    content_part="${line:${multiline_indent}}"
                fi
                multiline_content+="${content_part}"$'\n'
                continue
            else
                # End of multiline
                if [[ "${reading_multiline}" == "command" ]]; then
                    hook_command="${multiline_content%$'\n'}"
                elif [[ "${reading_multiline}" == "prompt" ]]; then
                    hook_prompt="${multiline_content%$'\n'}"
                fi
                reading_multiline=""
                multiline_content=""
                # Fall through to process current line
            fi
        fi

        # Detect top-level event (SessionStart:, UserPromptSubmit:, etc.)
        if [[ "${line}" =~ ^(SessionStart|UserPromptSubmit|PreToolUse|PostToolUse|Stop|SessionEnd):[[:space:]]*$ ]]; then
            # Save previous hook if exists
            if [[ "${in_hook_item}" == "true" && "${hook_enabled}" == "true" && -n "${hook_type}" ]]; then
                save_hook_to_event
            fi
            current_event="${BASH_REMATCH[1]}"
            in_hook_list=true
            in_hook_item=false
            log_verbose "Processing event: ${current_event}"
            continue
        fi

        # Skip comment lines and empty lines
        [[ "${line}" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        # Inside an event's hook list
        if [[ "${in_hook_list}" == "true" ]]; then
            # Detect new hook item (- name: "...")
            if [[ "${line}" =~ ^[[:space:]]+-[[:space:]]+name:[[:space:]]*[\"\']?([^\"\']+)[\"\']? ]]; then
                # Save previous hook if exists
                if [[ "${in_hook_item}" == "true" && "${hook_enabled}" == "true" && -n "${hook_type}" ]]; then
                    save_hook_to_event
                fi
                # Reset for new hook
                in_hook_item=true
                hook_enabled=""
                hook_matcher=""
                hook_timeout=""
                in_hooks_array=false
                hook_type=""
                hook_command=""
                hook_prompt=""
                continue
            fi

            # Parse hook properties
            if [[ "${in_hook_item}" == "true" ]]; then
                # enabled: true/false
                if [[ "${line}" =~ enabled:[[:space:]]*(true|false) ]]; then
                    hook_enabled="${BASH_REMATCH[1]}"
                    continue
                fi

                # matcher: "pattern"
                if [[ "${line}" =~ matcher:[[:space:]]*[\"\']?([^\"\']+)[\"\']? ]]; then
                    hook_matcher="${BASH_REMATCH[1]}"
                    continue
                fi

                # hooks: (array start)
                if [[ "${line}" =~ ^[[:space:]]+hooks:[[:space:]]*$ ]]; then
                    in_hooks_array=true
                    continue
                fi

                # Inside hooks array
                if [[ "${in_hooks_array}" == "true" ]]; then
                    # - type: "command"
                    if [[ "${line}" =~ -[[:space:]]+type:[[:space:]]*[\"\']?(command|prompt|agent)[\"\']? ]]; then
                        hook_type="${BASH_REMATCH[1]}"
                        continue
                    fi

                    # type: "command" (without dash)
                    if [[ "${line}" =~ ^[[:space:]]+type:[[:space:]]*[\"\']?(command|prompt|agent)[\"\']? ]]; then
                        hook_type="${BASH_REMATCH[1]}"
                        continue
                    fi

                    # timeout: 30
                    if [[ "${line}" =~ timeout:[[:space:]]*([0-9]+) ]]; then
                        hook_timeout="${BASH_REMATCH[1]}"
                        continue
                    fi

                    # command: | (multiline)
                    if [[ "${line}" =~ command:[[:space:]]*\|[[:space:]]*$ ]]; then
                        reading_multiline="command"
                        multiline_content=""
                        # Calculate indent for multiline content
                        if [[ "${line}" =~ ^([[:space:]]*) ]]; then
                            multiline_indent=$((${#BASH_REMATCH[1]} + 2))
                        fi
                        continue
                    fi

                    # command: "inline"
                    if [[ "${line}" =~ command:[[:space:]]*[\"\']([^\"\']+)[\"\'] ]]; then
                        hook_command="${BASH_REMATCH[1]}"
                        continue
                    fi

                    # prompt: | (multiline)
                    if [[ "${line}" =~ prompt:[[:space:]]*\|[[:space:]]*$ ]]; then
                        reading_multiline="prompt"
                        multiline_content=""
                        if [[ "${line}" =~ ^([[:space:]]*) ]]; then
                            multiline_indent=$((${#BASH_REMATCH[1]} + 2))
                        fi
                        continue
                    fi

                    # prompt: "inline"
                    if [[ "${line}" =~ prompt:[[:space:]]*[\"\']([^\"\']+)[\"\'] ]]; then
                        hook_prompt="${BASH_REMATCH[1]}"
                        continue
                    fi
                fi
            fi

            # Check if we've left the event (new top-level key)
            if [[ "${line}" =~ ^[a-zA-Z] && ! "${line}" =~ ^[[:space:]] ]]; then
                in_hook_list=false
            fi
        fi
    done < "${HOOKS_FILE}"

    # Save final hook if exists
    if [[ "${in_hook_item}" == "true" && "${hook_enabled}" == "true" && -n "${hook_type}" ]]; then
        save_hook_to_event
    fi

    # Build final JSON
    local hooks_json='{"_comment":"'"${GENERATED_MARKER}"' from .ai/hooks/hooks.yaml","hooks":{'
    local first_event=true

    for event in ${ALL_EVENTS}; do
        if [[ -n "${event_hooks[${event}]}" ]]; then
            [[ "${first_event}" != "true" ]] && hooks_json+=","
            hooks_json+="\"${event}\":[${event_hooks[${event}]}]"
            first_event=false
        fi
    done

    hooks_json+='}}'

    # Format JSON if jq is available
    if command_exists jq; then
        hooks_json=$(echo "${hooks_json}" | jq '.' 2>/dev/null) || true
    fi

    write_file "${CLAUDE_SETTINGS}" "${hooks_json}"
    log_success "Generated Claude Code hooks settings"
}

# Helper function to save current hook to event array
save_hook_to_event() {
    local hook_json=""

    # Build hook JSON
    if [[ -n "${hook_matcher}" ]]; then
        hook_json='{"matcher":"'"${hook_matcher}"'","hooks":[{"type":"'"${hook_type}"'"'
    else
        hook_json='{"hooks":[{"type":"'"${hook_type}"'"'
    fi

    # Add timeout if specified
    if [[ -n "${hook_timeout}" ]]; then
        hook_json+=',"timeout":'"${hook_timeout}"
    fi

    # Add type-specific content
    if [[ "${hook_type}" == "command" && -n "${hook_command}" ]]; then
        # Escape special chars in command for JSON
        local escaped_cmd="${hook_command//\\/\\\\}"
        escaped_cmd="${escaped_cmd//\"/\\\"}"
        escaped_cmd="${escaped_cmd//$'\n'/\\n}"
        escaped_cmd="${escaped_cmd//$'\t'/\\t}"
        hook_json+=',"command":"'"${escaped_cmd}"'"'
    elif [[ "${hook_type}" == "prompt" && -n "${hook_prompt}" ]]; then
        local escaped_prompt="${hook_prompt//\\/\\\\}"
        escaped_prompt="${escaped_prompt//\"/\\\"}"
        escaped_prompt="${escaped_prompt//$'\n'/\\n}"
        hook_json+=',"prompt":"'"${escaped_prompt}"'"'
    elif [[ "${hook_type}" == "agent" && -n "${hook_prompt}" ]]; then
        local escaped_prompt="${hook_prompt//\\/\\\\}"
        escaped_prompt="${escaped_prompt//\"/\\\"}"
        escaped_prompt="${escaped_prompt//$'\n'/\\n}"
        hook_json+=',"prompt":"'"${escaped_prompt}"'"'
    fi

    hook_json+='}]}'

    # Append to event's hook array
    if [[ -n "${event_hooks[${current_event}]}" ]]; then
        event_hooks["${current_event}"]+=",${hook_json}"
    else
        event_hooks["${current_event}"]="${hook_json}"
    fi

    log_verbose "Added hook to ${current_event}: type=${hook_type}"
}

# Generate MEMORY.md from MEMORY.yaml
generate_memory_md() {
    log_info "Generating MEMORY.md..."

    if [[ ! -f "${MEMORY_YAML}" ]]; then
        log_warn "MEMORY.yaml not found: ${MEMORY_YAML}"
        return 0
    fi

    local content="# Project memory"$'\n\n'
    content+="> Persistent memory for AI agents. Read at session start, update via \`memory-keeper\`."$'\n'
    content+="> **Source of truth**: \`prompts/fr/metametaprompts/data/memory/MEMORY.yaml\`"$'\n\n'

    # Extract identity
    local name type created main_lang paradigm
    name=$(yaml_get "${MEMORY_YAML}" "  name")
    type=$(yaml_get "${MEMORY_YAML}" "  type")
    created=$(yaml_get "${MEMORY_YAML}" "  created")
    main_lang=$(yaml_get "${MEMORY_YAML}" "  main_language")
    paradigm=$(yaml_get "${MEMORY_YAML}" "  paradigm")

    content+="## Project identity"$'\n\n'
    content+="| Property | Value |"$'\n'
    content+="|----------|-------|"$'\n'
    content+="| Name | ${name:-Meta-prompt-LLM} |"$'\n'
    content+="| Type | ${type:-Prompt framework} |"$'\n'
    content+="| Created | ${created:-2026-01-31} |"$'\n'
    content+="| Main language | ${main_lang:-English} |"$'\n'
    content+="| Paradigm | ${paradigm:-Doc-driven} |"$'\n\n'

    # Description
    content+="## Description"$'\n\n'
    local desc
    desc=$(yaml_get_block "${MEMORY_YAML}" "description")
    if [[ -n "${desc}" ]]; then
        content+="${desc}"$'\n'
    fi

    # User preferences
    content+="## User preferences"$'\n\n'
    content+="| Preference | Value |"$'\n'
    content+="|------------|-------|"$'\n'
    local pref_lang pref_code inc_writing shell_std ai_cov summary
    pref_lang=$(yaml_get "${MEMORY_YAML}" "  language_interface")
    pref_code=$(yaml_get "${MEMORY_YAML}" "  language_code_docs")
    inc_writing=$(yaml_get "${MEMORY_YAML}" "  inclusive_writing")
    shell_std=$(yaml_get "${MEMORY_YAML}" "  shell_standard")
    ai_cov=$(yaml_get "${MEMORY_YAML}" "  ai_tools_coverage")
    summary=$(yaml_get "${MEMORY_YAML}" "  end_of_response_summary")
    content+="| Language (interface) | ${pref_lang:-French} |"$'\n'
    content+="| Language (code/docs) | ${pref_code:-English} |"$'\n'
    content+="| Inclusive writing | ${inc_writing:-true} |"$'\n'
    content+="| Shell standard | ${shell_std:-Bash} |"$'\n'
    content+="| AI tools coverage | ${ai_cov:-Maximum} |"$'\n'
    content+="| End-of-response summary | ${summary:-true} |"$'\n\n'

    # Available skills
    content+="## Available skills"$'\n\n'
    content+="| Skill | Purpose | Status |"$'\n'
    content+="|-------|---------|--------|"$'\n'

    local skill_file
    for skill_file in $(get_skill_files); do
        local skill_name skill_desc
        skill_name=$(yaml_get "${skill_file}" "name")
        skill_desc=$(yaml_get "${skill_file}" "description")
        if [[ -n "${skill_name}" ]]; then
            content+="| ${skill_name} | ${skill_desc:-No description} | Active |"$'\n'
        fi
    done
    content+=$'\n'

    # Notes section
    content+="## Notes"$'\n\n'
    content+="- All prompts must follow \`prompts/_TEMPLATE.md\`"$'\n'
    content+="- Run \`generate.sh\` after any skill modification"$'\n'
    content+="- French content must use inclusive writing"$'\n'
    content+="- **Source of truth**: \`prompts/fr/metametaprompts/data/\`"$'\n'
    content+="- **Generated files**: \`.ai/\` (never edit directly)"$'\n'
    content+="- Use \`@future-self\` in commits to leave notes for future sessions"$'\n\n'

    # Platform support matrix
    content+="## Platform Support Matrix"$'\n\n'
    content+="| Platform | Rating | Limitations |"$'\n'
    content+="|----------|--------|-------------|"$'\n'
    content+="| Claude Code | â˜…â˜…â˜…â˜…â˜… | None - all 6 events + agent hooks |"$'\n'
    content+="| Cursor | â˜…â˜…â˜…â˜…â˜† | No SessionStart, no agent hooks |"$'\n'
    content+="| OpenCode | â˜…â˜…â˜…â˜†â˜† | Requires oh-my-opencode plugin |"$'\n'
    content+="| Codex CLI | â˜…â˜…â˜†â˜†â˜† | Only notify on agent-turn-complete |"$'\n'
    content+="| Aider | â˜…â˜†â˜†â˜†â˜† | No hooks, only auto_lint/test_cmd |"$'\n'
    content+="| Continue.dev | â˜…â˜†â˜†â˜†â˜† | Data events only, no command hooks |"$'\n\n'

    # Footer
    local updated updated_by session
    updated=$(yaml_get "${MEMORY_YAML}" "updated")
    updated_by=$(yaml_get "${MEMORY_YAML}" "updated_by")
    session=$(yaml_get "${MEMORY_YAML}" "session")
    content+="---"$'\n\n'
    content+="*Last updated: ${updated:-unknown} by ${updated_by:-unknown} (session ${session:-unknown})*"$'\n'
    content+="*Generated from: prompts/fr/metametaprompts/data/memory/MEMORY.yaml*"$'\n'

    write_file "${MEMORY_MD}" "${content}"
    log_success "Generated MEMORY.md"
}

# Update VERSION file
update_version() {
    local skills_hash
    skills_hash=$(compute_skills_hash)
    local version="1.0.0-${skills_hash}"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Would update VERSION to: ${version}"
    else
        echo "${version}" > "${VERSION_FILE}"
        log_success "Updated VERSION: ${version}"
    fi
}

# ----------------------------------------------------------------------------
# Main execution
# ----------------------------------------------------------------------------

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                FORCE=true
                shift
                ;;
            --check)
                CHECK_ONLY=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    log_info "Meta-prompt-LLM configuration generator"
    log_info "Project root: ${PROJECT_ROOT}"

    # Check if skills directory exists
    if [[ ! -d "${SKILLS_DIR}" ]]; then
        log_error "Skills directory not found: ${SKILLS_DIR}"
        exit 1
    fi

    # Count skill files
    local skill_count
    skill_count=$(get_skill_files | wc -l)
    log_info "Found ${skill_count} skill files"

    if [[ "${skill_count}" -eq 0 ]]; then
        log_warn "No skill files found in ${SKILLS_DIR}"
        log_warn "Skipping generation"
        exit 0
    fi

    # Check if regeneration is needed
    if [[ "${FORCE}" != "true" ]] && ! needs_regeneration; then
        log_success "Already up to date (use --force to regenerate)"
        if [[ "${CHECK_ONLY}" == "true" ]]; then
            exit 0
        fi
        return 0
    fi

    if [[ "${CHECK_ONLY}" == "true" ]]; then
        log_warn "Regeneration needed"
        exit 1
    fi

    # Sync from data/ source of truth
    sync_skills
    sync_hooks
    sync_commands

    # Run all generators
    generate_memory_md
    generate_agents_md
    generate_claude_md
    generate_claude_agents
    generate_claude_hooks
    generate_cursorrules
    generate_cursor_hooks
    generate_continuerc
    generate_aider_conf
    generate_ollama_modelfiles
    generate_opencode_agents
    generate_opencode_hooks
    generate_codex_agents
    generate_codex_config

    # Update version
    update_version

    log_success "Generation complete!"

    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "(Dry run - no files were written)"
    fi
}

main "$@"
